<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo King India - Complete Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 800px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .current-player {
            font-size: 1.2em;
            font-weight: bold;
        }

        .dice-container {
            text-align: center;
            margin: 20px 0;
        }

        .dice {
            width: 80px;
            height: 80px;
            border: 3px solid #333;
            border-radius: 15px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
        }

        .dice:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .dice.rolling {
            animation: roll 0.5s ease-in-out;
        }

        @keyframes roll {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            100% { transform: rotate(360deg); }
        }

        .board {
            width: 500px;
            height: 500px;
            border: 3px solid #333;
            position: relative;
            margin: 20px auto;
            background: #fff;
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
        }

        .cell {
            border: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cell:hover {
            background-color: #f0f0f0;
        }

        .home-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 2px;
        }

        .home-cell {
            width: 45%;
            height: 45%;
            border: 1px solid #333;
            border-radius: 50%;
            margin: 1px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pawn {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #000;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        .pawn:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .pawn.red { background-color: #e74c3c; }
        .pawn.blue { background-color: #3498db; }
        .pawn.yellow { background-color: #f1c40f; }
        .pawn.green { background-color: #27ae60; }

        .pawn.movable {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Home areas */
        .red-home { background-color: #ffebee; }
        .blue-home { background-color: #e3f2fd; }
        .yellow-home { background-color: #fffde7; }
        .green-home { background-color: #e8f5e8; }

        /* Safe zones */
        .safe-zone {
            background-color: #f0f0f0;
            position: relative;
        }

        .safe-zone::after {
            content: 'â˜…';
            color: #ffd700;
            font-size: 16px;
            position: absolute;
            top: 2px;
            right: 2px;
        }

        /* Winning paths */
        .red-path { background-color: #ffcdd2; }
        .blue-path { background-color: #bbdefb; }
        .yellow-path { background-color: #fff9c4; }
        .green-path { background-color: #c8e6c9; }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 10px;
            font-size: 1.1em;
        }

        .winner {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            font-weight: bold;
            animation: celebration 2s ease-in-out;
        }

        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .player-card {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player-card.active {
            border-color: #333;
            transform: scale(1.05);
        }

        .player-card.red { background-color: #ffebee; }
        .player-card.blue { background-color: #e3f2fd; }
        .player-card.yellow { background-color: #fffde7; }
        .player-card.green { background-color: #e8f5e8; }

        .game-log {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        @media (max-width: 768px) {
            .board {
                width: 350px;
                height: 350px;
            }
            
            .dice {
                width: 60px;
                height: 60px;
                font-size: 1.5em;
            }
            
            .pawn {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ðŸŽ² Ludo King India ðŸ‡®ðŸ‡³</h1>
        </div>

        <div class="player-stats" id="playerStats">
            <div class="player-card red" id="player0">
                <h3>Player 1 (Red)</h3>
                <p>Home: <span id="red-home-count">4</span></p>
                <p>Finished: <span id="red-finished">0</span></p>
            </div>
            <div class="player-card blue" id="player1">
                <h3>Player 2 (Blue)</h3>
                <p>Home: <span id="blue-home-count">4</span></p>
                <p>Finished: <span id="blue-finished">0</span></p>
            </div>
            <div class="player-card yellow" id="player2">
                <h3>Player 3 (Yellow)</h3>
                <p>Home: <span id="yellow-home-count">4</span></p>
                <p>Finished: <span id="yellow-finished">0</span></p>
            </div>
            <div class="player-card green" id="player3">
                <h3>Player 4 (Green)</h3>
                <p>Home: <span id="green-home-count">4</span></p>
                <p>Finished: <span id="green-finished">0</span></p>
            </div>
        </div>

        <div class="game-info">
            <div class="current-player" id="currentPlayer">Current Player: Player 1 (Red)</div>
            <div class="consecutive-sixes">Consecutive 6s: <span id="sixCount">0</span></div>
        </div>

        <div class="dice-container">
            <div class="dice" id="dice1" onclick="rollDice()">?</div>
            <button class="btn" onclick="rollDice()">Roll Dice</button>
        </div>

        <div class="status" id="gameStatus">Roll the dice to start playing!</div>

        <div class="board" id="gameBoard"></div>

        <div class="controls">
            <button class="btn" onclick="resetGame()">New Game</button>
            <button class="btn" onclick="toggleSound()">ðŸ”Š Sound</button>
        </div>

        <div class="game-log" id="gameLog">
            <div class="log-entry">Game started! Player 1 (Red) goes first.</div>
        </div>
    </div>

    <script>
        class LudoGame {
            constructor() {
                this.players = ['red', 'blue', 'yellow', 'green'];
                this.currentPlayer = 0;
                this.gameState = 'waiting'; // waiting, rolling, moving, finished
                this.consecutiveSixes = 0;
                this.soundEnabled = true;
                
                // Board positions for each color's path
                this.boardPath = this.generateBoardPath();
                this.safePaths = this.generateSafePaths();
                
                // Game state
                this.pawns = {
                    red: [{ position: -1, id: 0 }, { position: -1, id: 1 }, { position: -1, id: 2 }, { position: -1, id: 3 }],
                    blue: [{ position: -1, id: 0 }, { position: -1, id: 1 }, { position: -1, id: 2 }, { position: -1, id: 3 }],
                    yellow: [{ position: -1, id: 0 }, { position: -1, id: 1 }, { position: -1, id: 2 }, { position: -1, id: 3 }],
                    green: [{ position: -1, id: 0 }, { position: -1, id: 1 }, { position: -1, id: 2 }, { position: -1, id: 3 }]
                };
                
                this.lastRoll = 0;
                this.winner = null;
                
                this.initializeBoard();
                this.updateDisplay();
            }

            generateBoardPath() {
                // This creates the main circular path that all players follow
                const path = [];
                
                // Starting from red's entry point and going clockwise
                // Red starts at position 1 (row 6, col 1)
                // Each player has their own starting position on the main track
                
                // This is a simplified path - in a real implementation, 
                // you'd map out all 52 positions around the board
                for (let i = 0; i < 52; i++) {
                    path.push(this.getPositionCoordinates(i));
                }
                
                return path;
            }

            getPositionCoordinates(position) {
                // Convert linear position to board coordinates
                // This is a simplified version - you'd need to map the actual Ludo board path
                const boardSize = 15;
                
                if (position < 13) {
                    // Top row moving right
                    return { row: 6, col: position + 1 };
                } else if (position < 26) {
                    // Right column moving down
                    return { row: position - 13 + 7, col: 8 };
                } else if (position < 39) {
                    // Bottom row moving left
                    return { row: 8, col: 8 - (position - 26) };
                } else {
                    // Left column moving up
                    return { row: 8 - (position - 39), col: 6 };
                }
            }

            generateSafePaths() {
                return {
                    red: [{ row: 7, col: 1 }, { row: 7, col: 2 }, { row: 7, col: 3 }, { row: 7, col: 4 }, { row: 7, col: 5 }],
                    blue: [{ row: 1, col: 7 }, { row: 2, col: 7 }, { row: 3, col: 7 }, { row: 4, col: 7 }, { row: 5, col: 7 }],
                    yellow: [{ row: 7, col: 13 }, { row: 7, col: 12 }, { row: 7, col: 11 }, { row: 7, col: 10 }, { row: 7, col: 9 }],
                    green: [{ row: 13, col: 7 }, { row: 12, col: 7 }, { row: 11, col: 7 }, { row: 10, col: 7 }, { row: 9, col: 7 }]
                };
            }

            initializeBoard() {
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Add home areas
                        if (this.isHomeArea(row, col)) {
                            cell.className += ' home-area ' + this.getHomeColor(row, col) + '-home';
                            cell.innerHTML = this.createHomeCells(this.getHomeColor(row, col));
                        }
                        
                        // Add safe zones
                        if (this.isSafeZone(row, col)) {
                            cell.className += ' safe-zone';
                        }
                        
                        // Add winning paths
                        const pathColor = this.getPathColor(row, col);
                        if (pathColor) {
                            cell.className += ' ' + pathColor + '-path';
                        }
                        
                        board.appendChild(cell);
                    }
                }
                
                this.placePawnsOnBoard();
            }

            isHomeArea(row, col) {
                return (row < 6 && col < 6) || (row < 6 && col > 8) || 
                       (row > 8 && col < 6) || (row > 8 && col > 8);
            }

            getHomeColor(row, col) {
                if (row < 6 && col < 6) return 'red';
                if (row < 6 && col > 8) return 'blue';
                if (row > 8 && col < 6) return 'green';
                if (row > 8 && col > 8) return 'yellow';
                return '';
            }

            createHomeCells(color) {
                let html = '';
                for (let i = 0; i < 4; i++) {
                    html += `<div class="home-cell" data-color="${color}" data-home-index="${i}"></div>`;
                }
                return html;
            }

            isSafeZone(row, col) {
                const safePositions = [
                    {row: 6, col: 2}, {row: 2, col: 6}, {row: 6, col: 12}, {row: 12, col: 6},
                    {row: 8, col: 2}, {row: 2, col: 8}, {row: 8, col: 12}, {row: 12, col: 8}
                ];
                return safePositions.some(pos => pos.row === row && pos.col === col);
            }

            getPathColor(row, col) {
                if (row === 7 && col >= 1 && col <= 5) return 'red';
                if (col === 7 && row >= 1 && row <= 5) return 'blue';
                if (row === 7 && col >= 9 && col <= 13) return 'yellow';
                if (col === 7 && row >= 9 && row <= 13) return 'green';
                return null;
            }

            placePawnsOnBoard() {
                // Clear existing pawns
                document.querySelectorAll('.pawn').forEach(pawn => pawn.remove());
                
                // Place pawns in home areas
                this.players.forEach((color, playerIndex) => {
                    this.pawns[color].forEach((pawn, pawnIndex) => {
                        if (pawn.position === -1) {
                            // Pawn is at home
                            const homeCell = document.querySelector(
                                `.home-cell[data-color="${color}"][data-home-index="${pawnIndex}"]`
                            );
                            if (homeCell) {
                                const pawnElement = this.createPawnElement(color, pawnIndex);
                                homeCell.appendChild(pawnElement);
                            }
                        } else if (pawn.position >= 0 && pawn.position < 52) {
                            // Pawn is on the board
                            const pos = this.getPositionCoordinates(pawn.position);
                            const cell = document.querySelector(
                                `.cell[data-row="${pos.row}"][data-col="${pos.col}"]`
                            );
                            if (cell) {
                                const pawnElement = this.createPawnElement(color, pawnIndex);
                                cell.appendChild(pawnElement);
                            }
                        }
                    });
                });
            }

            createPawnElement(color, index) {
                const pawn = document.createElement('div');
                pawn.className = `pawn ${color}`;
                pawn.dataset.color = color;
                pawn.dataset.index = index;
                pawn.textContent = index + 1;
                pawn.onclick = () => this.movePawn(color, index);
                return pawn;
            }

            rollDice() {
                if (this.gameState === 'moving') {
                    this.showStatus('Please move a pawn first!');
                    return;
                }
                
                const dice = document.getElementById('dice1');
                dice.classList.add('rolling');
                
                // Play sound effect
                if (this.soundEnabled) {
                    this.playSound('dice');
                }
                
                setTimeout(() => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    this.lastRoll = roll;
                    dice.textContent = roll;
                    dice.classList.remove('rolling');
                    
                    this.handleDiceRoll(roll);
                }, 500);
            }

            handleDiceRoll(roll) {
                this.addToLog(`Player ${this.currentPlayer + 1} rolled a ${roll}`);
                
                if (roll === 6) {
                    this.consecutiveSixes++;
                    if (this.consecutiveSixes >= 3) {
                        this.addToLog(`Player ${this.currentPlayer + 1} rolled 3 consecutive 6s! Turn skipped.`);
                        this.consecutiveSixes = 0;
                        this.nextPlayer();
                        return;
                    }
                } else {
                    this.consecutiveSixes = 0;
                }
                
                const movablePawns = this.getMovablePawns(this.players[this.currentPlayer], roll);
                
                if (movablePawns.length === 0) {
                    this.showStatus('No valid moves available!');
                    setTimeout(() => {
                        if (roll !== 6) {
                            this.nextPlayer();
                        }
                    }, 1500);
                } else {
                    this.showStatus(`Choose a pawn to move ${roll} steps`);
                    this.highlightMovablePawns(movablePawns);
                    this.gameState = 'moving';
                }
                
                this.updateDisplay();
            }

            getMovablePawns(color, roll) {
                const movablePawns = [];
                
                this.pawns[color].forEach((pawn, index) => {
                    if (pawn.position === -1 && roll === 6) {
                        // Pawn can leave home
                        movablePawns.push(index);
                    } else if (pawn.position >= 0 && pawn.position + roll <= 56) {
                        // Pawn can move on board (including safe path)
                        movablePawns.push(index);
                    }
                });
                
                return movablePawns;
            }

            highlightMovablePawns(movablePawns) {
                document.querySelectorAll('.pawn').forEach(pawn => {
                    pawn.classList.remove('movable');
                });
                
                const currentColor = this.players[this.currentPlayer];
                movablePawns.forEach(index => {
                    const pawn = document.querySelector(
                        `.pawn[data-color="${currentColor}"][data-index="${index}"]`
                    );
                    if (pawn) {
                        pawn.classList.add('movable');
                    }
                });
            }

            movePawn(color, index) {
                if (this.gameState !== 'moving') return;
                if (color !== this.players[this.currentPlayer]) return;
                
                const pawn = this.pawns[color][index];
                const movablePawns = this.getMovablePawns(color, this.lastRoll);
                
                if (!movablePawns.includes(index)) {
                    this.showStatus('This pawn cannot be moved!');
                    return;
                }
                
                // Move the pawn
                if (pawn.position === -1 && this.lastRoll === 6) {
                    // Pawn leaving home
                    pawn.position = this.getStartPosition(color);
                    this.addToLog(`Player ${this.currentPlayer + 1} brought a pawn out of home!`);
                } else {
                    // Regular move
                    const newPosition = pawn.position + this.lastRoll;
                    
                    if (newPosition > 51) {
                        // Moving into safe path
                        const safePathPosition = newPosition - 52;
                        if (safePathPosition <= 5) {
                            pawn.position = 52 + safePathPosition;
                            if (safePathPosition === 5) {
                                // Pawn reached home
                                pawn.position = 100; // Special value for finished pawns
                                this.addToLog(`Player ${this.currentPlayer + 1} got a pawn home!`);
                                this.checkWinner();
                            }
                        }
                    } else {
                        pawn.position = newPosition;
                        this.checkCapture(color, index, newPosition);
                    }
                }
                
                this.placePawnsOnBoard();
                this.gameState = 'waiting';
                
                // Check if player gets another turn
                if (this.lastRoll === 6 && this.winner === null) {
                    this.showStatus(`Player ${this.currentPlayer + 1} gets another turn!`);
                } else {
                    this.nextPlayer();
                }
                
                this.updateDisplay();
            }

            getStartPosition(color) {
                const startPositions = { red: 1, blue: 14, yellow: 27, green: 40 };
                return startPositions[color];
            }

            checkCapture(movingColor, movingIndex, newPosition) {
                // Check if any opponent pawns are at the new position
                this.players.forEach(color => {
                    if (color === movingColor) return;
                    
                    this.pawns[color].forEach((pawn, index) => {
                        if (pawn.position === newPosition && !this.isSafeZone(...this.getPositionCoordinates(newPosition))) {
                            // Capture!
                            pawn.position = -1; // Send back to home
                            this.addToLog(`Player ${this.currentPlayer + 1} captured ${color} pawn!`);
                            if (this.soundEnabled) {
                                this.playSound('capture');
                            }
                        }
                    });
                });
            }

            checkWinner() {
                const finishedPawns = this.pawns[this.players[this.currentPlayer]].filter(
                    pawn => pawn.position === 100
                ).length;
                
                if (finishedPawns === 4) {
                    this.winner = this.currentPlayer;
                    this.gameState = 'finished';
                    this.showStatus(`ðŸŽ‰ Player ${this.currentPlayer + 1} (${this.players[this.currentPlayer]}) wins! ðŸŽ‰`, true);
                    if (this.soundEnabled) {
                        this.playSound('win');
                    }
                }
            }

            nextPlayer() {
                this.currentPlayer = (this.currentPlayer + 1) % 4;
                this.consecutiveSixes = 0;
                this.updateDisplay();
            }

            updateDisplay() {
                // Update current player
                document.getElementById('currentPlayer').textContent = 
                    `Current Player: Player ${this.currentPlayer + 1} (${this.players[this.currentPlayer]})`;
                
                // Update consecutive sixes
                document.getElementById('sixCount').textContent = this.consecutiveSixes;
                
                // Update player stats
                this.players.forEach((color, index) => {
                    const homeCount = this.pawns[color].filter(pawn => pawn.position === -1).length;
                    const finishedCount = this.pawns[color].filter(pawn => pawn.position === 100).length;
                    
                    document.getElementById(`${color}-home-count`).textContent = homeCount;
                    document.getElementById(`${color}-finished`).textContent = finishedCount;
                    
                    const playerCard = document.getElementById(`player${index}`);
                    if (index === this.currentPlayer && this.winner === null) {
                        playerCard.classList.add('active');
                    } else {
                        playerCard.classList.remove('active');
                    }
                });
            }

            showStatus(message, isWinner = false) {
                const status = document.getElementById('gameStatus');
                status.textContent = message;
                status.className = isWinner ? 'status winner' : 'status';
            }

            addToLog(message) {
                const log = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }

            playSound(type) {
                // Create audio context for sound effects
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'dice':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                        break;
                    case 'capture':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime + 0.2);
                        break;
                    case 'win':
                        oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.2);
                        oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.4);
                        break;
                }
                
                gainNode.gain.setValueAt